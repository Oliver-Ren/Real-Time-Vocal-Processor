// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2013.2
// Copyright (C) 2013 Xilinx Inc. All rights reserved.
// 
// ==============================================================

// Port list: {  1 3  }


#ifndef _pitchshifting_wn_V_H_
#define _pitchshifting_wn_V_H_



#include <systemc>
#include <iostream>
#include <fstream>
#include "AESL_pkg.h"

template<unsigned int READ_PORT_COUNT = 1,
         unsigned int WRITE_PORT_COUNT = 1,
         unsigned int DATA_WIDTH = 8,
         unsigned int ADDRESS_WIDTH = 8,
         unsigned int WORD_COUNT = 256>
struct pitchshifting_wn_V_core : public sc_core::sc_module
{
public:
    sc_core::sc_in< sc_dt::sc_lv< WRITE_PORT_COUNT*DATA_WIDTH > > d;
    sc_core::sc_out< sc_dt::sc_lv< READ_PORT_COUNT*DATA_WIDTH > > q;
    sc_core::sc_in < sc_dt::sc_lv< READ_PORT_COUNT*ADDRESS_WIDTH > > ra;
    sc_core::sc_in < sc_dt::sc_lv< READ_PORT_COUNT > > ce;
    sc_core::sc_in < sc_dt::sc_lv< WRITE_PORT_COUNT*ADDRESS_WIDTH > > wa;
    sc_core::sc_in < sc_dt::sc_lv< WRITE_PORT_COUNT > > we;
    sc_core::sc_in <sc_dt::sc_logic>  reset;
    sc_core::sc_in_clk  clk;

    SC_HAS_PROCESS(pitchshifting_wn_V_core);
    pitchshifting_wn_V_core(sc_core::sc_module_name) {
        mem = new sc_dt::sc_lv< DATA_WIDTH> [WORD_COUNT];

        SC_METHOD(proc_di);
        sensitive << d;

        SC_METHOD(proc_wai);
        sensitive << wa;

        SC_METHOD(proc_mem);
        sensitive << clk.pos();

        SC_METHOD(proc_rai);
        sensitive << ra;

        SC_METHOD(proc_rai_reg);
        sensitive << clk.pos();

        SC_METHOD(proc_qi);
        sensitive << clk;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            sensitive << rai_reg[i];
        }

        SC_METHOD(proc_q);
        sensitive << qi;

        for (unsigned i = 0; i < 41 ; i = i + 1) {
            mem[i] = "000000";
        }
        for (unsigned i = 41; i < 58 ; i = i + 1) {
            mem[i] = "000001";
        }
        for (unsigned i = 58; i < 71 ; i = i + 1) {
            mem[i] = "000010";
        }
        for (unsigned i = 71; i < 82 ; i = i + 1) {
            mem[i] = "000011";
        }
        for (unsigned i = 82; i < 92 ; i = i + 1) {
            mem[i] = "000100";
        }
        for (unsigned i = 92; i < 101 ; i = i + 1) {
            mem[i] = "000101";
        }
        for (unsigned i = 101; i < 110 ; i = i + 1) {
            mem[i] = "000110";
        }
        for (unsigned i = 110; i < 118 ; i = i + 1) {
            mem[i] = "000111";
        }
        for (unsigned i = 118; i < 125 ; i = i + 1) {
            mem[i] = "001000";
        }
        for (unsigned i = 125; i < 132 ; i = i + 1) {
            mem[i] = "001001";
        }
        for (unsigned i = 132; i < 139 ; i = i + 1) {
            mem[i] = "001010";
        }
        for (unsigned i = 139; i < 146 ; i = i + 1) {
            mem[i] = "001011";
        }
        for (unsigned i = 146; i < 152 ; i = i + 1) {
            mem[i] = "001100";
        }
        for (unsigned i = 152; i < 159 ; i = i + 1) {
            mem[i] = "001101";
        }
        for (unsigned i = 159; i < 165 ; i = i + 1) {
            mem[i] = "001110";
        }
        for (unsigned i = 165; i < 171 ; i = i + 1) {
            mem[i] = "001111";
        }
        for (unsigned i = 171; i < 176 ; i = i + 1) {
            mem[i] = "010000";
        }
        for (unsigned i = 176; i < 182 ; i = i + 1) {
            mem[i] = "010001";
        }
        for (unsigned i = 182; i < 188 ; i = i + 1) {
            mem[i] = "010010";
        }
        for (unsigned i = 188; i < 193 ; i = i + 1) {
            mem[i] = "010011";
        }
        for (unsigned i = 193; i < 199 ; i = i + 1) {
            mem[i] = "010100";
        }
        for (unsigned i = 199; i < 204 ; i = i + 1) {
            mem[i] = "010101";
        }
        for (unsigned i = 204; i < 210 ; i = i + 1) {
            mem[i] = "010110";
        }
        for (unsigned i = 210; i < 215 ; i = i + 1) {
            mem[i] = "010111";
        }
        for (unsigned i = 215; i < 220 ; i = i + 1) {
            mem[i] = "011000";
        }
        for (unsigned i = 220; i < 225 ; i = i + 1) {
            mem[i] = "011001";
        }
        for (unsigned i = 225; i < 230 ; i = i + 1) {
            mem[i] = "011010";
        }
        for (unsigned i = 230; i < 236 ; i = i + 1) {
            mem[i] = "011011";
        }
        for (unsigned i = 236; i < 241 ; i = i + 1) {
            mem[i] = "011100";
        }
        for (unsigned i = 241; i < 246 ; i = i + 1) {
            mem[i] = "011101";
        }
        for (unsigned i = 246; i < 251 ; i = i + 1) {
            mem[i] = "011110";
        }
        for (unsigned i = 251; i < 256 ; i = i + 1) {
            mem[i] = "011111";
        }
        for (unsigned i = 256; i < 261 ; i = i + 1) {
            mem[i] = "100000";
        }
        for (unsigned i = 261; i < 266 ; i = i + 1) {
            mem[i] = "100001";
        }
        for (unsigned i = 266; i < 271 ; i = i + 1) {
            mem[i] = "100010";
        }
        for (unsigned i = 271; i < 276 ; i = i + 1) {
            mem[i] = "100011";
        }
        for (unsigned i = 276; i < 282 ; i = i + 1) {
            mem[i] = "100100";
        }
        for (unsigned i = 282; i < 287 ; i = i + 1) {
            mem[i] = "100101";
        }
        for (unsigned i = 287; i < 292 ; i = i + 1) {
            mem[i] = "100110";
        }
        for (unsigned i = 292; i < 297 ; i = i + 1) {
            mem[i] = "100111";
        }
        for (unsigned i = 297; i < 302 ; i = i + 1) {
            mem[i] = "101000";
        }
        for (unsigned i = 302; i < 308 ; i = i + 1) {
            mem[i] = "101001";
        }
        for (unsigned i = 308; i < 313 ; i = i + 1) {
            mem[i] = "101010";
        }
        for (unsigned i = 313; i < 319 ; i = i + 1) {
            mem[i] = "101011";
        }
        for (unsigned i = 319; i < 324 ; i = i + 1) {
            mem[i] = "101100";
        }
        for (unsigned i = 324; i < 330 ; i = i + 1) {
            mem[i] = "101101";
        }
        for (unsigned i = 330; i < 336 ; i = i + 1) {
            mem[i] = "101110";
        }
        for (unsigned i = 336; i < 341 ; i = i + 1) {
            mem[i] = "101111";
        }
        for (unsigned i = 341; i < 347 ; i = i + 1) {
            mem[i] = "110000";
        }
        for (unsigned i = 347; i < 353 ; i = i + 1) {
            mem[i] = "110001";
        }
        for (unsigned i = 353; i < 360 ; i = i + 1) {
            mem[i] = "110010";
        }
        for (unsigned i = 360; i < 366 ; i = i + 1) {
            mem[i] = "110011";
        }
        for (unsigned i = 366; i < 373 ; i = i + 1) {
            mem[i] = "110100";
        }
        for (unsigned i = 373; i < 380 ; i = i + 1) {
            mem[i] = "110101";
        }
        for (unsigned i = 380; i < 387 ; i = i + 1) {
            mem[i] = "110110";
        }
        for (unsigned i = 387; i < 394 ; i = i + 1) {
            mem[i] = "110111";
        }
        for (unsigned i = 394; i < 402 ; i = i + 1) {
            mem[i] = "111000";
        }
        for (unsigned i = 402; i < 411 ; i = i + 1) {
            mem[i] = "111001";
        }
        for (unsigned i = 411; i < 420 ; i = i + 1) {
            mem[i] = "111010";
        }
        for (unsigned i = 420; i < 430 ; i = i + 1) {
            mem[i] = "111011";
        }
        for (unsigned i = 430; i < 441 ; i = i + 1) {
            mem[i] = "111100";
        }
        for (unsigned i = 441; i < 454 ; i = i + 1) {
            mem[i] = "111101";
        }
        for (unsigned i = 454; i < 471 ; i = i + 1) {
            mem[i] = "111110";
        }
        for (unsigned i = 471; i < 553 ; i = i + 1) {
            mem[i] = "111111";
        }
        for (unsigned i = 553; i < 570 ; i = i + 1) {
            mem[i] = "111110";
        }
        for (unsigned i = 570; i < 583 ; i = i + 1) {
            mem[i] = "111101";
        }
        for (unsigned i = 583; i < 594 ; i = i + 1) {
            mem[i] = "111100";
        }
        for (unsigned i = 594; i < 604 ; i = i + 1) {
            mem[i] = "111011";
        }
        for (unsigned i = 604; i < 613 ; i = i + 1) {
            mem[i] = "111010";
        }
        for (unsigned i = 613; i < 622 ; i = i + 1) {
            mem[i] = "111001";
        }
        for (unsigned i = 622; i < 630 ; i = i + 1) {
            mem[i] = "111000";
        }
        for (unsigned i = 630; i < 637 ; i = i + 1) {
            mem[i] = "110111";
        }
        for (unsigned i = 637; i < 644 ; i = i + 1) {
            mem[i] = "110110";
        }
        for (unsigned i = 644; i < 651 ; i = i + 1) {
            mem[i] = "110101";
        }
        for (unsigned i = 651; i < 658 ; i = i + 1) {
            mem[i] = "110100";
        }
        for (unsigned i = 658; i < 664 ; i = i + 1) {
            mem[i] = "110011";
        }
        for (unsigned i = 664; i < 671 ; i = i + 1) {
            mem[i] = "110010";
        }
        for (unsigned i = 671; i < 677 ; i = i + 1) {
            mem[i] = "110001";
        }
        for (unsigned i = 677; i < 683 ; i = i + 1) {
            mem[i] = "110000";
        }
        for (unsigned i = 683; i < 688 ; i = i + 1) {
            mem[i] = "101111";
        }
        for (unsigned i = 688; i < 694 ; i = i + 1) {
            mem[i] = "101110";
        }
        for (unsigned i = 694; i < 700 ; i = i + 1) {
            mem[i] = "101101";
        }
        for (unsigned i = 700; i < 705 ; i = i + 1) {
            mem[i] = "101100";
        }
        for (unsigned i = 705; i < 711 ; i = i + 1) {
            mem[i] = "101011";
        }
        for (unsigned i = 711; i < 716 ; i = i + 1) {
            mem[i] = "101010";
        }
        for (unsigned i = 716; i < 722 ; i = i + 1) {
            mem[i] = "101001";
        }
        for (unsigned i = 722; i < 727 ; i = i + 1) {
            mem[i] = "101000";
        }
        for (unsigned i = 727; i < 732 ; i = i + 1) {
            mem[i] = "100111";
        }
        for (unsigned i = 732; i < 737 ; i = i + 1) {
            mem[i] = "100110";
        }
        for (unsigned i = 737; i < 742 ; i = i + 1) {
            mem[i] = "100101";
        }
        for (unsigned i = 742; i < 748 ; i = i + 1) {
            mem[i] = "100100";
        }
        for (unsigned i = 748; i < 753 ; i = i + 1) {
            mem[i] = "100011";
        }
        for (unsigned i = 753; i < 758 ; i = i + 1) {
            mem[i] = "100010";
        }
        for (unsigned i = 758; i < 763 ; i = i + 1) {
            mem[i] = "100001";
        }
        for (unsigned i = 763; i < 768 ; i = i + 1) {
            mem[i] = "100000";
        }
        for (unsigned i = 768; i < 773 ; i = i + 1) {
            mem[i] = "011111";
        }
        for (unsigned i = 773; i < 778 ; i = i + 1) {
            mem[i] = "011110";
        }
        for (unsigned i = 778; i < 783 ; i = i + 1) {
            mem[i] = "011101";
        }
        for (unsigned i = 783; i < 788 ; i = i + 1) {
            mem[i] = "011100";
        }
        for (unsigned i = 788; i < 794 ; i = i + 1) {
            mem[i] = "011011";
        }
        for (unsigned i = 794; i < 799 ; i = i + 1) {
            mem[i] = "011010";
        }
        for (unsigned i = 799; i < 804 ; i = i + 1) {
            mem[i] = "011001";
        }
        for (unsigned i = 804; i < 809 ; i = i + 1) {
            mem[i] = "011000";
        }
        for (unsigned i = 809; i < 814 ; i = i + 1) {
            mem[i] = "010111";
        }
        for (unsigned i = 814; i < 820 ; i = i + 1) {
            mem[i] = "010110";
        }
        for (unsigned i = 820; i < 825 ; i = i + 1) {
            mem[i] = "010101";
        }
        for (unsigned i = 825; i < 831 ; i = i + 1) {
            mem[i] = "010100";
        }
        for (unsigned i = 831; i < 836 ; i = i + 1) {
            mem[i] = "010011";
        }
        for (unsigned i = 836; i < 842 ; i = i + 1) {
            mem[i] = "010010";
        }
        for (unsigned i = 842; i < 848 ; i = i + 1) {
            mem[i] = "010001";
        }
        for (unsigned i = 848; i < 853 ; i = i + 1) {
            mem[i] = "010000";
        }
        for (unsigned i = 853; i < 859 ; i = i + 1) {
            mem[i] = "001111";
        }
        for (unsigned i = 859; i < 865 ; i = i + 1) {
            mem[i] = "001110";
        }
        for (unsigned i = 865; i < 872 ; i = i + 1) {
            mem[i] = "001101";
        }
        for (unsigned i = 872; i < 878 ; i = i + 1) {
            mem[i] = "001100";
        }
        for (unsigned i = 878; i < 885 ; i = i + 1) {
            mem[i] = "001011";
        }
        for (unsigned i = 885; i < 892 ; i = i + 1) {
            mem[i] = "001010";
        }
        for (unsigned i = 892; i < 899 ; i = i + 1) {
            mem[i] = "001001";
        }
        for (unsigned i = 899; i < 906 ; i = i + 1) {
            mem[i] = "001000";
        }
        for (unsigned i = 906; i < 914 ; i = i + 1) {
            mem[i] = "000111";
        }
        for (unsigned i = 914; i < 923 ; i = i + 1) {
            mem[i] = "000110";
        }
        for (unsigned i = 923; i < 932 ; i = i + 1) {
            mem[i] = "000101";
        }
        for (unsigned i = 932; i < 942 ; i = i + 1) {
            mem[i] = "000100";
        }
        for (unsigned i = 942; i < 953 ; i = i + 1) {
            mem[i] = "000011";
        }
        for (unsigned i = 953; i < 966 ; i = i + 1) {
            mem[i] = "000010";
        }
        for (unsigned i = 966; i < 983 ; i = i + 1) {
            mem[i] = "000001";
        }
        for (unsigned i = 983; i < 1024 ; i = i + 1) {
            mem[i] = "000000";
        }
    }


    void proc_di()
    {
        sc_dt::sc_lv<DATA_WIDTH> dt;
        for (unsigned i = 0; i < WRITE_PORT_COUNT; i++) {
            for (unsigned j = 0; j < DATA_WIDTH; j++) {
                dt.set_bit(j, d.read()[i * DATA_WIDTH + j].value());
            }
            di[i].write(dt);
        }
    }

    void proc_wai()
    {
        sc_dt::sc_lv<ADDRESS_WIDTH> wat;
        for (unsigned i = 0; i < WRITE_PORT_COUNT; i++) {
            for (unsigned j = 0; j < ADDRESS_WIDTH; j++) {
                wat.set_bit(j, wa.read()[i * ADDRESS_WIDTH + j].value());
            }
            wai[i].write(wat);
        }
    }


    void proc_mem()
    {
        for (unsigned j = 0; j < WRITE_PORT_COUNT; j++) {
          if (we.read().get_bit(j) == 1) {
            unsigned i = wai[j].read().to_uint();
            if (!wai[j].read().is_01() || i >= WORD_COUNT) {
               cerr << "In memory model " << name() << ", during a write cycle\n";
               if (!wai[j].read().is_01()) 
                 cerr << "ERROR: address is not stable =" << wai[j].read() << endl;
               else
                 cerr << "ERROR: Address " << i << " for port '" << j << "' is outside the legal range [0.."
                      << (WORD_COUNT - 1) << "]." << endl;
               SC_REPORT_FATAL(1000, 0);
            }
            assert(wai[j].read().is_01());
            assert(i < WORD_COUNT);
            mem[i] = di[j];
          }
        }
    }


    void proc_rai()
    {
        sc_dt::sc_lv<ADDRESS_WIDTH> rat;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            for (unsigned j = 0; j < ADDRESS_WIDTH; j++) {
                rat.set_bit(j, ra.read()[i * ADDRESS_WIDTH + j].value());
            }
            rai[i].write(rat);
        }
    }

    void proc_rai_reg()
    {
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            if ( ce.read().get_bit(i) == 1) {
                rai_reg[i] = rai[i];
            }
        }
    }

    void proc_qi()
    {
        sc_dt::sc_lv<DATA_WIDTH> qt;
        sc_dt::sc_lv<READ_PORT_COUNT*DATA_WIDTH> qit;
        for (unsigned i = 0; i < READ_PORT_COUNT; i++) {
            if (!(rai_reg[i].read().is_01())) 
                qt = sc_dt::sc_lv<DATA_WIDTH>();
            else 
            {
                unsigned addr = rai_reg[i].read().to_uint();
                if (addr >= WORD_COUNT) {
                    qt = sc_dt::sc_lv<DATA_WIDTH>();
                }
                else {
                    qt = mem[addr];
                }
            }
            for (unsigned j = 0; j < DATA_WIDTH; j++) {
                qit.set_bit(i*DATA_WIDTH+j, qt[j].value());
            }
        }
        qi.write(qit);
    }


    void proc_q()
    {
        q.write(qi.read());
    }

    ~pitchshifting_wn_V_core() {
        delete [] mem;
    }

public:
    sc_dt::sc_lv< DATA_WIDTH>*  mem;
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > wai[ WRITE_PORT_COUNT ];
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > rai[READ_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<ADDRESS_WIDTH> > rai_reg[READ_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<DATA_WIDTH> > di[WRITE_PORT_COUNT];
    sc_core::sc_signal<sc_dt::sc_lv<READ_PORT_COUNT*DATA_WIDTH> > qi;
};

  


SC_MODULE( pitchshifting_wn_V )
{
    static const unsigned int DataWidth = 6;
    static const unsigned int AddressRange = 1024;
    static const unsigned int AddressWidth = 10;


    sc_core::sc_in<sc_dt::sc_lv<AddressWidth> > address0;
    sc_core::sc_in<sc_dt::sc_logic> ce0;
    sc_core::sc_out<sc_dt::sc_lv<DataWidth> > q0;


    sc_core::sc_in<sc_dt::sc_logic> reset;
    sc_core::sc_in_clk clk;


    SC_CTOR( pitchshifting_wn_V ) {
        meminst = new pitchshifting_wn_V_core <1, 1, DataWidth, AddressWidth, AddressRange>("core_inst");

        meminst->d(mem_d);
        meminst->q(mem_q);
        meminst->ra(mem_ra);
        meminst->ce(mem_ce);
        meminst->wa(mem_wa);
        meminst->we(mem_we);
        meminst->reset(reset);
        meminst->clk(clk);

        SC_METHOD(proc_mem_q);
        sensitive << mem_q;

        SC_METHOD(proc_mem_ra);
        sensitive << address0;

        SC_METHOD(proc_mem_ce);
        sensitive << ce0;

        mem_wa.write(0);
        mem_we.write(0);
        mem_d.write(0);
    }

    ~pitchshifting_wn_V() {
        delete meminst;
    }

    void proc_mem_q();
    void proc_mem_ra();
    void proc_mem_ce();

public:
    sc_core::sc_signal<sc_dt::sc_lv<1 * DataWidth> > mem_q;
    sc_core::sc_signal<sc_dt::sc_lv<1> > mem_we;
    sc_core::sc_signal<sc_dt::sc_lv<1 * DataWidth> > mem_d;
    sc_core::sc_signal<sc_dt::sc_lv<1 * AddressWidth> > mem_wa;
    sc_core::sc_signal<sc_dt::sc_lv<1 * AddressWidth> > mem_ra;
    sc_core::sc_signal<sc_dt::sc_lv<1> > mem_ce;

    pitchshifting_wn_V_core <1, 1, DataWidth, AddressWidth, AddressRange>* meminst;
};

#endif //_pitchshifting_wn_V_H_
